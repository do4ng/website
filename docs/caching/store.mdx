`$store` is a function that stores the return value of another function.

The first argument accepts the function you want to store, and the second argument accepts a `dependencies` value used to specify a unique ID.

The compiler, [serpack](/serpack/introduction), automatically assigns a unique ID to each `$store` function, allowing it to work seamlessly.

## $store

```ts {11}
import { GET } from "@zely-js/core";
import { setTimeout } from "timers/promises";

async function slowGreeting() {
  await setTimeout(1000);
  return "Hello, Doe!";
}

export default [
  GET(async (ctx) => {
    const { data } = await $store(slowGreeting);
    ctx.send(data);
  }),
];
```

<Box type="tip">
  You don't need to import any other modules. Just use the `$store` function
  directly.
</Box>

After the first request, the `$greeting` function will no longer be executed (during ttl).

## Dependencies

To handle dynamically changing dependencies, you can register dependencies with the store.

```ts
$store(fn, [someDep]);
```

Data is separated and stored based on the registered dependency value.

<Box type="warning">
  Each item in dependencies must be of type string or Context.
</Box>

## Context as Dependencies

If the context is provided as `dependencies`, `$store` will automatically analyze the `params` and generate a unique ID.

```ts
export default [
  GET(async (ctx) => {
    await $store(fn, ctx);
    // ...
  }),
];
```
